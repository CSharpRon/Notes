<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Zettlr" />
  <meta name="date" content="" />
  <title>Motion Planning and Search</title>
  <style type="text/css">
  * {
    box-sizing: border-box;
  }

  a {
    color: #FF7C3B;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  hr {
    border: none;
    border-bottom: 1px solid #999;
    width: 80%;
  }

  html, body {
    margin: 0;
    padding: 0;
  }

  body {
    background-color: white;
    color: #333;
    font-family: 'DejaVu', 'Georgia', 'Times New Roman', 'Times', serif;
  }

  article {
    width: 50%;
    font-size: 1.5em;
    margin: 0 auto;
    line-height: 150%;
  }

  /* Better display on printing */
  @media print {
    article {
      width: 90%;
      font-size: 12pt;
      margin: 0 auto;
      line-height: 150%;
    }
  }

  article p {
    hyphens: auto;
    text-align: justify;
  }

  h1, h2, h3, h4, h5, h6 {
    font-family: 'Raleway', 'Lato', 'Liberation sans', 'Helvetica', sans-serif;
    color: #FF7C3B;
  }

  img {
    max-width: 100%;
    height: auto;
  }

  blockquote {
    font-size: 80%;
    color: rgba(120, 120, 120, 1);
    margin: 2% 5%;
    line-height: 120%;
  }

  table {
    border-collapse: collapse;
    width: 100%;
    font-size: 70%;
    font-family: 'Raleway', 'Lato', 'Liberation sans', 'Helvetica', sans-serif;
  }

  th, td {
    padding: 4px 20px;
    border-bottom: 1px solid #333;
  }

  /* List of classes taken from the skylighting lib */
  /* See: https://github.com/jgm/skylighting/blob/master/skylighting-core/src/Skylighting/Format/HTML.hs */

  /* Colors: Solarized theme (light) */
  /* See: https://ethanschoonover.com/solarized/ */

  /* Specific implementation: Taken from the GEdit theme (light) */
  /* See: https://github.com/altercation/solarized/blob/master/gedit/solarized-light.xml */

  /* Generic styles */
  pre.sourceCode {
    color: #657b83;
    background-color: #fdf6e3;
    box-shadow: 0px 0px 20px 0px rgba(0, 0, 0, .05);
    padding: 2px;
    overflow: auto;
  }

  /* All classes, taken from skylighting lib */
  .sourceCode .kw { color: #859900; font-weight: bold; } /* Keyword */
  .sourceCode .dt { color: #b58900; } /* Datatype */
  .sourceCode .df { color: #d33682; } /* Decimal values*/
  .sourceCode .bn { color: #d33682; } /* base-n-integers */
  .sourceCode .fl { color: #d33682; } /* Floats */
  .sourceCode .ch { color: #2aa198; } /* Character */
  .sourceCode .st { color: #2aa198; } /* String */
  .sourceCode .vs { color: #2aa198; } /* Verbatim String */
  .sourceCode .ss { color: #2aa198; } /* Special String */
  .sourceCode .co { color: #586e75; font-style: italic; } /* Comment */
  .sourceCode .ot { font-weight: bold; } /* Other token */
  .sourceCode .al { color: #d33682; background-color: #073642; } /* Alert */
  .sourceCode .fu { color: #268bd2; } /* Function name */
  .sourceCode .re {} /* Region marker */
  .sourceCode .er { color: #dc322f; font-weight: bold; } /* Error */
  .sourceCode .cn { color: #2aa198; } /* Constant */
  .sourceCode .sc { color: #dc322f; } /* Special character */
  .sourceCode .im { color: #6c71c4; font-weight: bold; } /* Import statement */
  .sourceCode .do { color: #dc322f; } /* Documentation string */
  .sourceCode .an { color: #2aa198; } /* Annotation */
  .sourceCode .cv { color: #6c71c4; } /* Comment var */
  .sourceCode .va { color: #268bd2; } /* Variable */
  .sourceCode .cf { color: #859900; } /* Control Flow (if, else, return) */
  .sourceCode .op {} /* Operator */
  .sourceCode .bu { color: #b58900; } /* Builtin function/class/identifier */
  .sourceCode .ex { color: #268bd2; } /* Extension */
  .sourceCode .pp { color: #cb4b16; } /* Preprocessor, like #import in C++ */
  .sourceCode .at { color: #dc322f; } /* Attribute */
  .sourceCode .in { color: #586e75; } /* Information */
  .sourceCode .wa { color: #cb4b16; } /* Warning */
  </style>

<!-- Pandoc variables -->
<meta name="keywords" content="A*, Motion Planning, Heuristic, Robotics" />

<!-- Additional CSS in case the user has passed it -->

<!-- Include MathJax CDN, if applicable -->
  <script src="/usr/share/javascript/mathjax/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
  <!-- Render in article for reader view enabling -->
    <article>
    <h1 id="motion-planning-and-search">Motion Planning and Search</h1>
    <h2 id="terms">Terms</h2>
    <p><strong>Motion Planning</strong> - The action of finding the path a robot needs to take to navigate to a target location.</p>
    <p><strong>Minimum Cost Path</strong> - The path with the least total cost from start to goal. Note that the minimum cost path may not be the “shortest” cost. A path that prioritizes right turns may have a lower cost than a path that consists of left turns.</p>
    <p><strong>A* Algorithm</strong> - A cost analysis algorithm which uses a heuristic function to limit the expansions performed on the movement grid to find the minimum cost path. As a result, not all nodes need to be traversed to find a minimum cost path.</p>
    <p><strong>Dynamic Programming Algorithm</strong> - A cost analysis algorithm which traverses through each cell in the grid and stores the mimum cost of traversal starting at any cell. This approach does not depend on the starting location.</p>
    <p><strong>Policy</strong> - A grid consisting of the optimal motion a car in each cell should take in order to reach the goal.</p>
    <hr />
    <h2 id="expansion">Expansion</h2>
    <p>Given the following:</p>
    <ul>
    <li>Map</li>
    <li>Starting Location</li>
    <li>Goal Location</li>
    <li>Cost of movement</li>
    </ul>
    <p><em>Find the minimum cost path.</em></p>
    <p>The least efficient algorithm to calculate the minimum cost path is to expand each adjacent node from the starting node until all of the nodes are traversed. By doing so, the costs will increase after each unexplored cell gets traversed. In the end, the minimum cost path with be traversable.</p>
    <div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">grid <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb1-2" title="2">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb1-3" title="3">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb1-4" title="4">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb1-5" title="5">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,]]</a>
    <a class="sourceLine" id="cb1-6" title="6">init <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb1-7" title="7">goal <span class="op">=</span> [<span class="bu">len</span>(grid)<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(grid[<span class="dv">0</span>])<span class="op">-</span><span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb1-8" title="8">cost <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb1-9" title="9"></a>
    <a class="sourceLine" id="cb1-10" title="10">delta <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], <span class="co"># go up</span></a>
    <a class="sourceLine" id="cb1-11" title="11">         [ <span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>], <span class="co"># go left</span></a>
    <a class="sourceLine" id="cb1-12" title="12">         [ <span class="dv">1</span>, <span class="dv">0</span>], <span class="co"># go down</span></a>
    <a class="sourceLine" id="cb1-13" title="13">         [ <span class="dv">0</span>, <span class="dv">1</span>]] <span class="co"># go right</span></a>
    <a class="sourceLine" id="cb1-14" title="14"></a>
    <a class="sourceLine" id="cb1-15" title="15"><span class="kw">def</span> search(grid,init,goal,cost):</a>
    <a class="sourceLine" id="cb1-16" title="16"></a>
    <a class="sourceLine" id="cb1-17" title="17">    <span class="co"># Closed consists of nodes that are expanded, so we do not expand them again</span></a>
    <a class="sourceLine" id="cb1-18" title="18">    expand <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]    </a>
    <a class="sourceLine" id="cb1-19" title="19">    closed <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb1-20" title="20">    closed[init[<span class="dv">0</span>]][init[<span class="dv">1</span>]] <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb1-21" title="21">    <span class="bu">open</span> <span class="op">=</span> ]</a>
    <a class="sourceLine" id="cb1-22" title="22">    found <span class="op">=</span> <span class="va">False</span> <span class="co"># Goal Position</span></a>
    <a class="sourceLine" id="cb1-23" title="23">    resign <span class="op">=</span> <span class="va">False</span> <span class="co"># No more expansions possible</span></a>
    <a class="sourceLine" id="cb1-24" title="24"></a>
    <a class="sourceLine" id="cb1-25" title="25">    <span class="cf">while</span> (<span class="kw">not</span> found <span class="kw">and</span> <span class="kw">not</span> resign):</a>
    <a class="sourceLine" id="cb1-26" title="26"></a>
    <a class="sourceLine" id="cb1-27" title="27">        <span class="cf">if</span> <span class="bu">len</span>(<span class="bu">open</span>) <span class="op">==</span> <span class="dv">0</span>:</a>
    <a class="sourceLine" id="cb1-28" title="28">            resign <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb1-29" title="29">            <span class="bu">print</span>(<span class="st">&quot;Failed!&quot;</span>)</a>
    <a class="sourceLine" id="cb1-30" title="30">            <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb1-31" title="31"></a>
    <a class="sourceLine" id="cb1-32" title="32">        <span class="co"># We want to analyze the smallest g value from the list</span></a>
    <a class="sourceLine" id="cb1-33" title="33">        <span class="bu">open</span>.sort()</a>
    <a class="sourceLine" id="cb1-34" title="34">        <span class="bu">open</span>.reverse()</a>
    <a class="sourceLine" id="cb1-35" title="35">        <span class="bu">next</span> <span class="op">=</span> <span class="bu">open</span>.pop()</a>
    <a class="sourceLine" id="cb1-36" title="36"></a>
    <a class="sourceLine" id="cb1-37" title="37">        x <span class="op">=</span> <span class="bu">next</span>[<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb1-38" title="38">        y <span class="op">=</span> <span class="bu">next</span>[<span class="dv">2</span>]</a>
    <a class="sourceLine" id="cb1-39" title="39">        g <span class="op">=</span> <span class="bu">next</span>[<span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb1-40" title="40"></a>
    <a class="sourceLine" id="cb1-41" title="41">        <span class="cf">if</span> [x,y] <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb1-42" title="42">            found <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb1-43" title="43">            <span class="bu">print</span>(<span class="bu">next</span>)</a>
    <a class="sourceLine" id="cb1-44" title="44">            <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb1-45" title="45"></a>
    <a class="sourceLine" id="cb1-46" title="46">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(delta)):</a>
    <a class="sourceLine" id="cb1-47" title="47">            x2 <span class="op">=</span> x <span class="op">+</span> delta[i][<span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb1-48" title="48">            y2 <span class="op">=</span> y <span class="op">+</span> delta[i][<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb1-49" title="49">            <span class="cf">if</span> x2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x2 <span class="op">&lt;</span> <span class="bu">len</span>(grid) <span class="kw">and</span> y2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> y2 <span class="op">&lt;</span> <span class="bu">len</span>(grid[<span class="dv">0</span>]):</a>
    <a class="sourceLine" id="cb1-50" title="50">                <span class="cf">if</span> closed[x2][y2] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> grid[x2][y2] <span class="op">==</span> <span class="dv">0</span>:</a>
    <a class="sourceLine" id="cb1-51" title="51">                    g2 <span class="op">=</span> g <span class="op">+</span> cost</a>
    <a class="sourceLine" id="cb1-52" title="52">                    <span class="bu">open</span>.append([g2,x2,y2])</a>
    <a class="sourceLine" id="cb1-53" title="53">                    closed[x2][y2] <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb1-54" title="54"></a>
    <a class="sourceLine" id="cb1-55" title="55">    <span class="cf">return</span> closed</a></code></pre></div>
    <hr />
    <h2 id="a">A*</h2>
    <p>The A* algorithm works by first calculating a heuristic of the same world grid.</p>
    <p><span class="math display">\[
    h(x,y) \le (euclideandistancefrom(x,y))
    \]</span></p>
    <p>After the heuristic grid is calculated, the robot can then begin it’s path planning. Continuing on from the expanded algorithm, each cell (starting from the initial cell) has the cost of the adjacent cells calculated and put into the <strong>open</strong> list. However, this time a new cost <em>f</em> is used to denote the cost where <em>f</em> is the sum of movement cost <em>g</em> and the corresponding heuristic value <em>h</em>.</p>
    <p><img src="/home/ronald/Documents/study-notes/Artificial%20Intelligence%20for%20Robotics/a-star.png" /></p>
    <div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">grid <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb2-2" title="2">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb2-3" title="3">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb2-4" title="4">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb2-5" title="5">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,]]</a>
    <a class="sourceLine" id="cb2-6" title="6">heuristic <span class="op">=</span> [[<span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>],</a>
    <a class="sourceLine" id="cb2-7" title="7">             [<span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>],</a>
    <a class="sourceLine" id="cb2-8" title="8">             [<span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>],</a>
    <a class="sourceLine" id="cb2-9" title="9">             [<span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>],</a>
    <a class="sourceLine" id="cb2-10" title="10">             [<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]]</a>
    <a class="sourceLine" id="cb2-11" title="11"></a>
    <a class="sourceLine" id="cb2-12" title="12">init <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb2-13" title="13">goal <span class="op">=</span> [<span class="bu">len</span>(grid)<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(grid[<span class="dv">0</span>])<span class="op">-</span><span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb2-14" title="14">cost <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb2-15" title="15"></a>
    <a class="sourceLine" id="cb2-16" title="16">delta <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go up</span></a>
    <a class="sourceLine" id="cb2-17" title="17">         [ <span class="dv">0</span>, <span class="dv">-1</span>], <span class="co"># go left</span></a>
    <a class="sourceLine" id="cb2-18" title="18">         [ <span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go down</span></a>
    <a class="sourceLine" id="cb2-19" title="19">         [ <span class="dv">0</span>, <span class="dv">1</span> ]] <span class="co"># go right</span></a>
    <a class="sourceLine" id="cb2-20" title="20"></a>
    <a class="sourceLine" id="cb2-21" title="21">delta_name <span class="op">=</span> [<span class="st">&#39;^&#39;</span>, <span class="st">&#39;&lt;&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;&gt;&#39;</span>]</a>
    <a class="sourceLine" id="cb2-22" title="22"></a>
    <a class="sourceLine" id="cb2-23" title="23"><span class="kw">def</span> search(grid,init,goal,cost,heuristic):</a>
    <a class="sourceLine" id="cb2-24" title="24"> <span class="co"># ----------------------------------------</span></a>
    <a class="sourceLine" id="cb2-25" title="25"> <span class="co"># modify the code below</span></a>
    <a class="sourceLine" id="cb2-26" title="26"> <span class="co"># ----------------------------------------</span></a>
    <a class="sourceLine" id="cb2-27" title="27">closed <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb2-28" title="28">closed[init[<span class="dv">0</span>]][init[<span class="dv">1</span>]] <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb2-29" title="29">expand <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb2-30" title="30">action <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb2-31" title="31"></a>
    <a class="sourceLine" id="cb2-32" title="32">x <span class="op">=</span> init[<span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb2-33" title="33">y <span class="op">=</span> init[<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb2-34" title="34">g <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb2-35" title="35">h <span class="op">=</span> heuristic[x][y]</a>
    <a class="sourceLine" id="cb2-36" title="36">f <span class="op">=</span> g <span class="op">+</span> h</a>
    <a class="sourceLine" id="cb2-37" title="37"></a>
    <a class="sourceLine" id="cb2-38" title="38"><span class="co">&quot;&quot;&quot; g is needed since it is the true cost of the action &quot;&quot;&quot;</span></a>
    <a class="sourceLine" id="cb2-39" title="39"><span class="bu">open</span> <span class="op">=</span> </a>
    <a class="sourceLine" id="cb2-40" title="40"></a>
    <a class="sourceLine" id="cb2-41" title="41">found <span class="op">=</span> <span class="va">False</span>  <span class="co"># flag that is set when search is complete</span></a>
    <a class="sourceLine" id="cb2-42" title="42">resign <span class="op">=</span> <span class="va">False</span> <span class="co"># flag set if we can&#39;t find expand</span></a>
    <a class="sourceLine" id="cb2-43" title="43">count <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb2-44" title="44"></a>
    <a class="sourceLine" id="cb2-45" title="45"><span class="co"># Resign indicates failure    </span></a>
    <a class="sourceLine" id="cb2-46" title="46"><span class="cf">while</span> <span class="kw">not</span> found <span class="kw">and</span> <span class="kw">not</span> resign:</a>
    <a class="sourceLine" id="cb2-47" title="47">    <span class="cf">if</span> <span class="bu">len</span>(<span class="bu">open</span>) <span class="op">==</span> <span class="dv">0</span>:</a>
    <a class="sourceLine" id="cb2-48" title="48">        resign <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb2-49" title="49">        <span class="cf">return</span> <span class="st">&quot;Fail&quot;</span></a>
    <a class="sourceLine" id="cb2-50" title="50">    <span class="cf">else</span>:</a>
    <a class="sourceLine" id="cb2-51" title="51"></a>
    <a class="sourceLine" id="cb2-52" title="52">        <span class="co"># Using the combined cost f is what makes a difference to the search here.</span></a>
    <a class="sourceLine" id="cb2-53" title="53">        <span class="co"># Since the list gets sorted by f, the cell with the minimum cost at this point</span></a>
    <a class="sourceLine" id="cb2-54" title="54">        <span class="co"># gets prioritized. In the best case, this means that we do not even need to traverse</span></a>
    <a class="sourceLine" id="cb2-55" title="55">        <span class="co"># through higher cost cells.</span></a>
    <a class="sourceLine" id="cb2-56" title="56">        <span class="bu">open</span>.sort()</a>
    <a class="sourceLine" id="cb2-57" title="57">        <span class="bu">open</span>.reverse()</a>
    <a class="sourceLine" id="cb2-58" title="58">        <span class="bu">next</span> <span class="op">=</span> <span class="bu">open</span>.pop()</a>
    <a class="sourceLine" id="cb2-59" title="59"></a>
    <a class="sourceLine" id="cb2-60" title="60">        x <span class="op">=</span> <span class="bu">next</span>[<span class="dv">2</span>]</a>
    <a class="sourceLine" id="cb2-61" title="61">        y <span class="op">=</span> <span class="bu">next</span>[<span class="dv">3</span>]</a>
    <a class="sourceLine" id="cb2-62" title="62">        g <span class="op">=</span> <span class="bu">next</span>[<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb2-63" title="63"></a>
    <a class="sourceLine" id="cb2-64" title="64">        expand[x][y] <span class="op">=</span> count</a>
    <a class="sourceLine" id="cb2-65" title="65">        count <span class="op">+=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb2-66" title="66"></a>
    <a class="sourceLine" id="cb2-67" title="67">        <span class="cf">if</span> x <span class="op">==</span> goal[<span class="dv">0</span>] <span class="kw">and</span> y <span class="op">==</span> goal[<span class="dv">1</span>]:</a>
    <a class="sourceLine" id="cb2-68" title="68">            found <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb2-69" title="69">        <span class="cf">else</span>:</a>
    <a class="sourceLine" id="cb2-70" title="70">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(delta)):</a>
    <a class="sourceLine" id="cb2-71" title="71">                x2 <span class="op">=</span> x <span class="op">+</span> delta[i][<span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb2-72" title="72">                y2 <span class="op">=</span> y <span class="op">+</span> delta[i][<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb2-73" title="73">                <span class="cf">if</span> x2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x2 <span class="op">&lt;</span> <span class="bu">len</span>(grid) <span class="kw">and</span> y2 <span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> y2 <span class="op">&lt;</span> <span class="bu">len</span>(grid[<span class="dv">0</span>]):</a>
    <a class="sourceLine" id="cb2-74" title="74">                    <span class="cf">if</span> closed[x2][y2] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> grid[x2][y2] <span class="op">==</span> <span class="dv">0</span>:</a>
    <a class="sourceLine" id="cb2-75" title="75">                        g2 <span class="op">=</span> g <span class="op">+</span> cost</a>
    <a class="sourceLine" id="cb2-76" title="76">                        h2 <span class="op">=</span> heuristic[x2][y2]</a>
    <a class="sourceLine" id="cb2-77" title="77">                        f2 <span class="op">=</span> g2 <span class="op">+</span> h2</a>
    <a class="sourceLine" id="cb2-78" title="78">                        <span class="bu">open</span>.append([f2, g2, x2, y2])</a>
    <a class="sourceLine" id="cb2-79" title="79">                        closed[x2][y2] <span class="op">=</span> <span class="dv">1</span></a>
    <a class="sourceLine" id="cb2-80" title="80"></a>
    <a class="sourceLine" id="cb2-81" title="81"><span class="cf">return</span> expand</a></code></pre></div>
    <blockquote>
    <p>Note, the major advantage of the A* algorithm is that in the best case, not all cells get traversed. As long as the heuristic function is calculated correctly, then the minimum cost path will be found without needing to look at each cell.</p>
    </blockquote>
    <hr />
    <h2 id="dynamic-programming">Dynamic Programming</h2>
    <p>This is the most computationally expensive but also most flexible approach to path planning. Rather than focusing on a starting location, each grid cell is given a value equal to the minimum cost needed to reach the goal <strong>from that location.</strong> This function is O(n) complexity but has the benefit of providing a least cost function from <u>any</u> starting location.</p>
    <p>In addition to just calculating the cost, you can also create a <strong>policy</strong>, a copy of the grid which defines the optimal movement that the car should take in that cell to reach the goal.</p>
    <p><img src="/home/ronald/Documents/study-notes/Artificial%20Intelligence%20for%20Robotics/dynamic-programming.png" /></p>
    <div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">grid <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb3-2" title="2">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb3-3" title="3">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb3-4" title="4">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
    <a class="sourceLine" id="cb3-5" title="5">        [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]]</a>
    <a class="sourceLine" id="cb3-6" title="6">init <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb3-7" title="7">goal <span class="op">=</span> [<span class="bu">len</span>(grid)<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(grid[<span class="dv">0</span>])<span class="op">-</span><span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb3-8" title="8">cost <span class="op">=</span> <span class="dv">1</span> <span class="co"># the cost associated with moving from a cell to an adjacent one</span></a>
    <a class="sourceLine" id="cb3-9" title="9"></a>
    <a class="sourceLine" id="cb3-10" title="10">delta <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go up</span></a>
    <a class="sourceLine" id="cb3-11" title="11">         [ <span class="dv">0</span>, <span class="dv">-1</span>], <span class="co"># go left</span></a>
    <a class="sourceLine" id="cb3-12" title="12">         [ <span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go down</span></a>
    <a class="sourceLine" id="cb3-13" title="13">         [ <span class="dv">0</span>, <span class="dv">1</span> ]] <span class="co"># go right</span></a>
    <a class="sourceLine" id="cb3-14" title="14"></a>
    <a class="sourceLine" id="cb3-15" title="15">delta_name <span class="op">=</span> [<span class="st">&#39;^&#39;</span>, <span class="st">&#39;&lt;&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;&gt;&#39;</span>]</a>
    <a class="sourceLine" id="cb3-16" title="16"></a>
    <a class="sourceLine" id="cb3-17" title="17"><span class="kw">def</span> optimum_policy(grid,goal,cost):</a>
    <a class="sourceLine" id="cb3-18" title="18">value <span class="op">=</span> [[<span class="dv">99</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb3-19" title="19">policy <span class="op">=</span> [[<span class="st">&#39; &#39;</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb3-20" title="20">value[goal[<span class="dv">0</span>]][goal[<span class="dv">1</span>]] <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb3-21" title="21">policy[goal[<span class="dv">0</span>]][goal[<span class="dv">1</span>]] <span class="op">=</span> <span class="st">&#39;*&#39;</span></a>
    <a class="sourceLine" id="cb3-22" title="22"></a>
    <a class="sourceLine" id="cb3-23" title="23">changed <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb3-24" title="24"><span class="cf">while</span>(changed):</a>
    <a class="sourceLine" id="cb3-25" title="25">    changed <span class="op">=</span> <span class="va">False</span></a>
    <a class="sourceLine" id="cb3-26" title="26">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(value)):</a>
    <a class="sourceLine" id="cb3-27" title="27">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(value[i])):</a>
    <a class="sourceLine" id="cb3-28" title="28"></a>
    <a class="sourceLine" id="cb3-29" title="29">            <span class="co"># Skip goal pos</span></a>
    <a class="sourceLine" id="cb3-30" title="30">            <span class="cf">if</span> [i,j] <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb3-31" title="31">                <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb3-32" title="32"></a>
    <a class="sourceLine" id="cb3-33" title="33">            <span class="co"># Don&#39;t update the value for barrier grids</span></a>
    <a class="sourceLine" id="cb3-34" title="34">            <span class="cf">if</span> grid[i][j] <span class="op">==</span> <span class="dv">1</span>:</a>
    <a class="sourceLine" id="cb3-35" title="35">                <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb3-36" title="36"></a>
    <a class="sourceLine" id="cb3-37" title="37">            <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(delta)):</a>
    <a class="sourceLine" id="cb3-38" title="38">                x2 <span class="op">=</span> i <span class="op">+</span> delta[d][<span class="dv">0</span>]</a>
    <a class="sourceLine" id="cb3-39" title="39">                y2 <span class="op">=</span> j <span class="op">+</span> delta[d][<span class="dv">1</span>]</a>
    <a class="sourceLine" id="cb3-40" title="40">                <span class="co"># If in bounds</span></a>
    <a class="sourceLine" id="cb3-41" title="41">                <span class="cf">if</span> x2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x2 <span class="op">&lt;</span> <span class="bu">len</span>(grid) <span class="kw">and</span> y2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> y2 <span class="op">&lt;</span> <span class="bu">len</span>(grid[i]):</a>
    <a class="sourceLine" id="cb3-42" title="42">                    <span class="cf">if</span> value[x2][y2] <span class="op">&lt;</span> (value[i][j] <span class="op">-</span> cost):</a>
    <a class="sourceLine" id="cb3-43" title="43">                        policy[i][j] <span class="op">=</span> delta_name[d]</a>
    <a class="sourceLine" id="cb3-44" title="44">                        value[i][j] <span class="op">=</span> value[x2][y2] <span class="op">+</span> cost</a>
    <a class="sourceLine" id="cb3-45" title="45">                        changed <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb3-46" title="46"></a>
    <a class="sourceLine" id="cb3-47" title="47"><span class="cf">return</span> policy</a></code></pre></div>
    <hr />
    <h2 id="stochastic-motion">Stochastic Motion</h2>
    <p>In addition to calculating the minimum cost path, we must also account for randomness. <strong>Stochastic motion</strong> refers to the probability that the robot may not successfully perform its intended action. For example, if given a move forward command, assume that it has a 50% chance of performing the action successfully, a 25% chance of mistakenly going left, and a 25% chance of mistakenly going right.</p>
    <p>Given these probabilities, we can modify our dynamic programming function to have the minimum cost include these probabilities.</p>
    <div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">delta <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go up</span></a>
    <a class="sourceLine" id="cb4-2" title="2">         [ <span class="dv">0</span>, <span class="dv">-1</span>], <span class="co"># go left</span></a>
    <a class="sourceLine" id="cb4-3" title="3">         [ <span class="dv">1</span>, <span class="dv">0</span> ], <span class="co"># go down</span></a>
    <a class="sourceLine" id="cb4-4" title="4">         [ <span class="dv">0</span>, <span class="dv">1</span> ]] <span class="co"># go right</span></a>
    <a class="sourceLine" id="cb4-5" title="5"></a>
    <a class="sourceLine" id="cb4-6" title="6">delta_name <span class="op">=</span> [<span class="st">&#39;^&#39;</span>, <span class="st">&#39;&lt;&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;&gt;&#39;</span>] <span class="co"># Use these when creating your policy grid.</span></a>
    <a class="sourceLine" id="cb4-7" title="7"></a>
    <a class="sourceLine" id="cb4-8" title="8"><span class="co"># ---------------------------------------------</span></a>
    <a class="sourceLine" id="cb4-9" title="9"><span class="co">#  Modify the function stochastic_value below</span></a>
    <a class="sourceLine" id="cb4-10" title="10"><span class="co"># ---------------------------------------------</span></a>
    <a class="sourceLine" id="cb4-11" title="11"></a>
    <a class="sourceLine" id="cb4-12" title="12"><span class="kw">def</span> stochastic_value(grid,goal,cost_step,collision_cost,success_prob):</a>
    <a class="sourceLine" id="cb4-13" title="13"></a>
    <a class="sourceLine" id="cb4-14" title="14">    value <span class="op">=</span> [[collision_cost <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb4-15" title="15">    policy <span class="op">=</span> [[<span class="st">&#39; &#39;</span> <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[<span class="dv">0</span>]))] <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid))]</a>
    <a class="sourceLine" id="cb4-16" title="16"></a>
    <a class="sourceLine" id="cb4-17" title="17">    failure_prob <span class="op">=</span> (<span class="fl">1.0</span> <span class="op">-</span> success_prob)<span class="op">/</span><span class="fl">2.0</span> <span class="co"># Probability(stepping left) = prob(stepping right) = failure_prob </span></a>
    <a class="sourceLine" id="cb4-18" title="18"></a>
    <a class="sourceLine" id="cb4-19" title="19">    <span class="co"># Initialize the value of the goal</span></a>
    <a class="sourceLine" id="cb4-20" title="20">    value[goal[<span class="dv">0</span>]][goal[<span class="dv">1</span>]] <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb4-21" title="21">    policy[goal[<span class="dv">0</span>]][goal[<span class="dv">1</span>]] <span class="op">=</span> <span class="st">&#39;*&#39;</span></a>
    <a class="sourceLine" id="cb4-22" title="22"></a>
    <a class="sourceLine" id="cb4-23" title="23">    <span class="co"># Perform dynamic programming to compute the values for the entire grid</span></a>
    <a class="sourceLine" id="cb4-24" title="24">    changed <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb4-25" title="25">    <span class="cf">while</span>(changed):</a>
    <a class="sourceLine" id="cb4-26" title="26">        changed <span class="op">=</span> <span class="va">False</span></a>
    <a class="sourceLine" id="cb4-27" title="27">        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid)):</a>
    <a class="sourceLine" id="cb4-28" title="28">            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid[x])):</a>
    <a class="sourceLine" id="cb4-29" title="29"></a>
    <a class="sourceLine" id="cb4-30" title="30">                <span class="co"># Skip the goal</span></a>
    <a class="sourceLine" id="cb4-31" title="31">                <span class="cf">if</span> [x,y] <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb4-32" title="32">                    <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb4-33" title="33"></a>
    <a class="sourceLine" id="cb4-34" title="34">                <span class="co"># Skip occupied squares</span></a>
    <a class="sourceLine" id="cb4-35" title="35">                <span class="cf">if</span> grid[x][y] <span class="op">==</span> <span class="dv">1</span>:</a>
    <a class="sourceLine" id="cb4-36" title="36">                    <span class="cf">continue</span></a>
    <a class="sourceLine" id="cb4-37" title="37"></a>
    <a class="sourceLine" id="cb4-38" title="38">                <span class="co"># Otherwise, compare the surrounding blocks</span></a>
    <a class="sourceLine" id="cb4-39" title="39">                <span class="co"># At each block, the car has for possible directions it can choose to travel </span></a>
    <a class="sourceLine" id="cb4-40" title="40">                <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(delta)):</a>
    <a class="sourceLine" id="cb4-41" title="41"></a>
    <a class="sourceLine" id="cb4-42" title="42">                    <span class="co"># Regardless of which direction is taken, there are 3 possible outcomes. Forward Position (success) and 2 alternates</span></a>
    <a class="sourceLine" id="cb4-43" title="43">                    forwardPos <span class="op">=</span> [x <span class="op">+</span> delta[d][<span class="dv">0</span>], y <span class="op">+</span> delta[d][<span class="dv">1</span>]]</a>
    <a class="sourceLine" id="cb4-44" title="44">                    altPos1 <span class="op">=</span> [x <span class="op">+</span> delta[d<span class="dv">-1</span>][<span class="dv">0</span>], y <span class="op">+</span> delta[d<span class="dv">-1</span>][<span class="dv">1</span>]]</a>
    <a class="sourceLine" id="cb4-45" title="45">                    altPos2 <span class="op">=</span> [(x <span class="op">+</span> delta[(d<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(delta)][<span class="dv">0</span>]), (y <span class="op">+</span> delta[(d<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(delta)][<span class="dv">1</span>])]</a>
    <a class="sourceLine" id="cb4-46" title="46"></a>
    <a class="sourceLine" id="cb4-47" title="47">                    <span class="co"># Check the scenario for each of the stochastic operations</span></a>
    <a class="sourceLine" id="cb4-48" title="48"></a>
    <a class="sourceLine" id="cb4-49" title="49">                    <span class="co"># If the next position is the goal, it will have the lowest cost (0) so that it is prioritized</span></a>
    <a class="sourceLine" id="cb4-50" title="50">                    <span class="cf">if</span> forwardPos <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb4-51" title="51">                        forward_cost <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb4-52" title="52"></a>
    <a class="sourceLine" id="cb4-53" title="53">                    <span class="co"># If the next position is in bounds, calculate the normal cost</span></a>
    <a class="sourceLine" id="cb4-54" title="54">                    <span class="cf">elif</span> (forwardPos[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> forwardPos[<span class="dv">0</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid)) <span class="kw">and</span> (forwardPos[<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> forwardPos[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid[<span class="dv">0</span>])):</a>
    <a class="sourceLine" id="cb4-55" title="55">                        forward_cost <span class="op">=</span> success_prob <span class="op">*</span> value[forwardPos[<span class="dv">0</span>]][forwardPos[<span class="dv">1</span>]]</a>
    <a class="sourceLine" id="cb4-56" title="56"></a>
    <a class="sourceLine" id="cb4-57" title="57">                    <span class="co"># Otherwise, the next position is out of bounds and the cost is calculated from the collision value</span></a>
    <a class="sourceLine" id="cb4-58" title="58">                    <span class="cf">else</span>:</a>
    <a class="sourceLine" id="cb4-59" title="59">                        forward_cost <span class="op">=</span> success_prob <span class="op">*</span> collision_cost</a>
    <a class="sourceLine" id="cb4-60" title="60"></a>
    <a class="sourceLine" id="cb4-61" title="61">                    <span class="cf">if</span> altPos1 <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb4-62" title="62">                        alt1_cost <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb4-63" title="63">                    <span class="cf">elif</span> (altPos1[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> altPos1[<span class="dv">0</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid)) <span class="kw">and</span> (altPos1[<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> altPos1[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid[<span class="dv">0</span>])):</a>
    <a class="sourceLine" id="cb4-64" title="64">                        alt1_cost <span class="op">=</span> failure_prob <span class="op">*</span> value[altPos1[<span class="dv">0</span>]][altPos1[<span class="dv">1</span>]]</a>
    <a class="sourceLine" id="cb4-65" title="65">                    <span class="cf">else</span>:</a>
    <a class="sourceLine" id="cb4-66" title="66">                        alt1_cost <span class="op">=</span> failure_prob <span class="op">*</span> collision_cost </a>
    <a class="sourceLine" id="cb4-67" title="67"></a>
    <a class="sourceLine" id="cb4-68" title="68">                    <span class="cf">if</span> altPos2 <span class="op">==</span> goal:</a>
    <a class="sourceLine" id="cb4-69" title="69">                        alt2_cost <span class="op">=</span> <span class="dv">0</span></a>
    <a class="sourceLine" id="cb4-70" title="70">                    <span class="cf">elif</span> (altPos2[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> altPos2[<span class="dv">0</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid)) <span class="kw">and</span> (altPos2[<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> altPos2[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="bu">len</span>(grid[<span class="dv">0</span>])):</a>
    <a class="sourceLine" id="cb4-71" title="71">                        alt2_cost <span class="op">=</span> failure_prob <span class="op">*</span> value[altPos2[<span class="dv">0</span>]][altPos2[<span class="dv">1</span>]]</a>
    <a class="sourceLine" id="cb4-72" title="72">                    <span class="cf">else</span>:</a>
    <a class="sourceLine" id="cb4-73" title="73">                        alt2_cost <span class="op">=</span> failure_prob <span class="op">*</span> collision_cost</a>
    <a class="sourceLine" id="cb4-74" title="74"></a>
    <a class="sourceLine" id="cb4-75" title="75">                    <span class="co"># Sum of all costs</span></a>
    <a class="sourceLine" id="cb4-76" title="76">                    total_cost <span class="op">=</span> forward_cost <span class="op">+</span> alt1_cost <span class="op">+</span> alt2_cost <span class="op">+</span> cost_step</a>
    <a class="sourceLine" id="cb4-77" title="77"></a>
    <a class="sourceLine" id="cb4-78" title="78">                    <span class="cf">if</span> total_cost <span class="op">&lt;</span> value[x][y]:</a>
    <a class="sourceLine" id="cb4-79" title="79">                        value[x][y] <span class="op">=</span> total_cost</a>
    <a class="sourceLine" id="cb4-80" title="80">                        policy[x][y] <span class="op">=</span> delta_name[d]</a>
    <a class="sourceLine" id="cb4-81" title="81">                        changed <span class="op">=</span> <span class="va">True</span></a>
    <a class="sourceLine" id="cb4-82" title="82"></a>
    <a class="sourceLine" id="cb4-83" title="83">    <span class="cf">return</span> value, policy</a></code></pre></div>
    <h1 id="product-of-exponentials-formula-in-the-space-frame">4.1.1: Product of Exponentials Formula in the Space Frame</h1>
    <h2 id="terms-1">Terms:</h2>
    <p><strong>Forward Kinematics</strong></p>
    <ul>
    <li>Refers to the use of the kineamtic equations of a robot to compute the position of the <strong>end-effector</strong> from specified values for the joint parameters.</li>
    </ul>
    <p><strong>End Effector</strong></p>
    <ul>
    <li><p>Device at the end of a robotic arm designed to interact with the environment.</p>
    <ul>
    <li>End effectors are typically the <strong>grippers</strong> of a robot</li>
    </ul></li>
    </ul>
    <p><strong>Denavit-Hartenberg Parameters</strong></p>
    <ul>
    <li><p>Referred to as D-H Parameters</p></li>
    <li><p>Commonly used convention for selecting frames of reference to the links of a spatial kinematic chain</p></li>
    </ul>
    <p><strong>Product of Exponentials</strong></p>
    <ul>
    <li><p>Referred to as PoE</p></li>
    <li><p>Adjacent frames do not need to be considered.</p></li>
    <li><p>Only 2 frames are needed: Space Frame {s} and Tool Frame {b}</p></li>
    <li><p>6n numbers are needed to describe n screw axes</p></li>
    </ul>
    <hr />
    <h2 id="forward-kinematics">Forward Kinematics</h2>
    <ul>
    <li>Forward kinematics refers to the use of the kinematic equations of a robot to compute the <u>position of the end-effector</u> from specified values for the joint parameters.</li>
    </ul>
    <h2 id="problem">Problem</h2>
    <blockquote>
    <p>Define a frame {s} (often fixed at the base of a robot) and a frame {b} at the end effector of the robot arm.</p>
    <p>Calculate the Forward Kinematics of the robot: I.e., <span class="math inline">\(Find \newline T(\theta)\)</span></p>
    </blockquote>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-02-13-40-38-image.png" title="" alt="" data-align="center"></p>
    <h3 id="representing-forward-kinematics-in-the-s-frame">Representing Forward Kinematics in the {s} Frame</h3>
    <p><strong>Procedure:</strong></p>
    <ol type="1">
    <li><p>Let M be the transformation matrix of the end-effector frame {b} when <span class="math inline">\(\theta\)</span> = 0</p>
    <p>In other words, M is the position and orientation of the end effector when all joint angles are set to zero:</p>
    <p><span class="math display">\[
    x_b\quad y_b\quad z_b\quad
    \]</span></p>
    <p><span class="math display">\[
    M = 
    \begin{bmatrix}
    \hat{x_s} &amp; \hat{x_s} &amp; \hat{x_s} &amp; \sum{L}_{x_s} \\
    \hat{y_s} &amp; \hat{y_s} &amp; \hat{y_s} &amp; \sum{L}_{y_s} \\
    \hat{z_s} &amp; \hat{z_s} &amp; \hat{z_s} &amp; \sum{L}_{z_s} \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}
    \]</span></p>
    <ul>
    <li><p>The first three 3-vectors (x,y,z) denote which axis in the {s} frame corresponds to a value in the {b} frame. For example, a value of <span class="math inline">\([0, 1, 0]^T\)</span> in the first column means that the x axis of the {b} frame is aligned with the positive y axis of the {s} frame</p></li>
    <li><p>The bottom row is added to simplify matrix operations</p></li>
    <li><p>The <span class="math inline">\(\sum{L}\)</span> represents the sum of all of the links from the space frame {s} to the end effector.</p></li>
    </ul></li>
    <li><p>Find the {s} frame Screw Axes <span class="math inline">\(S_{1}, ..., S_n\)</span> for each of the n joint axes when <span class="math inline">\(\theta = 0\)</span></p>
    <p><span class="math display">\[
    S_n = 
    \begin{bmatrix}
    \omega \\
    v
    \end{bmatrix}
    = 
    \begin{bmatrix}
    \hat{x_s} \\
    \hat{y_s} \\
    \hat{z_s} \\ \\
    \dot{x_s} \\
    \dot{y_s} \\
    \dot{z_s}
    \end{bmatrix}
    \]</span></p>
    <ul>
    <li><p>The first 3-vector (angular velocity) represents which axis the space frame {s} is rotating about. For example, a value of <span class="math inline">\([0,0,1]^T\)</span> means that this joint in the {s} frame is rotating about the positive z-axis</p></li>
    <li><p>The linear velocity v can be found by identifying which axis is tangental to the turntable created at the center of the joint n and then multiplying that number with the distance that the joint is from the origin of the {s} frame.</p></li>
    <li><p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-03-21-39-12-image.png" /></p></li>
    </ul></li>
    <li><p>Given <span class="math inline">\(\theta\)</span>, calculate the product of exponentials (PoE) formula in the space frame:</p>
    <blockquote>
    <p><span class="math inline">\(T(\theta) = e^{[S_1]\theta_1}e^{[S_2]\theta_2}..e^{[s_n]\theta_n}M\)</span></p>
    </blockquote></li>
    </ol>
    <p><strong>Example:</strong></p>
    <p>Given a 4 joint RRRP Robot Arm, find the Forward Kinematics:</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-03-20-28-33-image.png" /></p>
    <p><u>1st, Find M:</u></p>
    <p><span class="math display">\[
    M = 
    \begin{bmatrix}
        0 &amp; -1 &amp; 0 &amp; 19 \\
        -1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; -1 &amp; -3 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}
    \]</span></p>
    <p><u>2nd, Find all Screw Axes:</u></p>
    <p><span class="math display">\[
    S_1 = 
    \begin{bmatrix}
        0 \\
        0 \\
        1 \\ \\
        0 \\
        0 \\
        0 \\
    \end{bmatrix}, 
    S_2 = 
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ \\
        0 \\ -10 \\ 0 
    \end{bmatrix},
    S_3 = 
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ \\
        0 \\ -19 \\ 0
    \end{bmatrix},
    S_4 = 
    \begin{bmatrix}
        0 \\ 0 \\ 0 \\ \\ 
        0 \\ 0 \\ 1
    \end{bmatrix}
    \]</span></p>
    <blockquote>
    <p>Note, for <span class="math inline">\(S_4\)</span>, the angular velocity is 0 because joint 4 is a prismatic joint which can only slide</p>
    </blockquote>
    <p><u>3rd, that’s it!</u></p>
    <p>We now have the elements necessary to calculate the forward kinematic of the robot T(<span class="math inline">\(\theta\)</span>) for any given theta</p>
    <hr />
    <h3 id="representing-forward-kinematics-in-the-b-frame">Representing Forward Kinematics in the {b} Frame</h3>
    <p><strong>Procedure:</strong></p>
    <ol type="1">
    <li><p><strong>Unchanged:</strong> Let M be the transformation matrix of the end-effector frame {b} when <span class="math inline">\(\theta\)</span> = 0</p>
    <p><span class="math display">\[
    x_b\quad y_b\quad z_b\quad
    \]</span></p>
    <p><span class="math display">\[
    M = 
    \begin{bmatrix}
    \hat{x_s} &amp; \hat{x_s} &amp; \hat{x_s} &amp; \sum{L}_{x_s} \\
    \hat{y_s} &amp; \hat{y_s} &amp; \hat{y_s} &amp; \sum{L}_{y_s} \\
    \hat{z_s} &amp; \hat{z_s} &amp; \hat{z_s} &amp; \sum{L}_{z_s} \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}
    \]</span></p></li>
    <li><p>Find the {b} frame Screw Axes <span class="math inline">\(\beta\)</span>_{1}, …, <span class="math inline">\(\beta\)</span>_n for each of the n joint axes when <span class="math inline">\(\theta\)</span> = 0</p>
    <p><span class="math display">\[
    \beta_n = 
    \begin{bmatrix}
    \omega \\
    v
    \end{bmatrix}
    = 
    \begin{bmatrix}
    \hat{x_b} \\
    \hat{y_b} \\
    \hat{z_b} \\ \\
    \dot{x_b} \\
    \dot{y_b} \\
    \dot{z_b}
    \end{bmatrix}
    \]</span></p>
    <ul>
    <li><p>The first 3-vector (angular velocity) represents which axis the space frame {b} is rotating about. For example, a value of [0,0,1]^T means that this joint in the {b} frame is rotating about the positive z-axis</p></li>
    <li><p>The linear velocity v can be found by identifying which axis is tangental to the turntable created at the center of the joint n and then multiplying that number with the distance that the joint is from the origin of the {b} frame.</p></li>
    </ul></li>
    <li><p>Given <span class="math inline">\(\theta\)</span>, calculate the product of exponentials (PoE) formula in the space frame:</p>
    <blockquote>
    <p><span class="math inline">\(T(\theta) = e^{[S_1]\theta_1}e^{[S_2]\theta_2}..e^{[s_n]\theta_n}M\)</span></p>
    </blockquote></li>
    </ol>
    <p><strong>Example:</strong></p>
    <p>Given a URRPR spatial open chain robot, determin the screw axis <span class="math inline">\(\beta_i\)</span> in {b} when the robot is in its zero position. <strong>L = 1.</strong></p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-06-13-11-13-image.png" /></p>
    <p><u>1st, Find M:</u></p>
    <p><span class="math display">\[
    M = 
    \begin{bmatrix}
        1 &amp; 0 &amp; 0 &amp; 3.73 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 2.73 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}
    \]</span></p>
    <p><u>2nd, Find all Screw Axes:</u></p>
    <p><span class="math display">\[
    \beta_1 = 
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ \\
        0 \\ 2.73 \\ 0 \\
    \end{bmatrix}, 
    \beta_2 = 
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ \\
        2.73 \\ 0 \\ -2.73 
    \end{bmatrix},
    \beta_3 = 
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ \\
        3.73 \\ 0 \\ -1
    \end{bmatrix},
    \beta_4 = 
    \begin{bmatrix}
        0 \\ 1 \\ 0 \\ \\ 
        2 \\ 0 \\ 0
    \end{bmatrix}
    \beta_5 = 
    \begin{bmatrix}
        0 \\ 0 \\ 0 \\ \\ 
        0 \\ 0 \\ 1
    \end{bmatrix}
    \beta_6 = 
    \begin{bmatrix}
        0 \\ 0 \\ 1 \\ \\ 
        0 \\ 0 \\ 0
    \end{bmatrix}
    \]</span></p>
    <blockquote>
    <p>Calculating the linear velocity looks complicated but is still quite simple. Take a look at <span class="math inline">\(\theta_1\)</span>. If you were to map that rotation onto the body frame {b}, you would notice that axis y is tangental to the rotation. It is also <strong>2.73 units away from the {b} frame</strong> which is why it gets the value assigned.</p>
    <p>Next, take a look at <span class="math inline">\(\theta_2\)</span>. It’s rotation is tangental to both the x and z frames, so those will be assigned values. It is translated along the <span class="math inline">\(z_b\)</span> axis by a unit of 2.73 and along the <span class="math inline">\(x_b\)</span> axis by a unit of 2.73. The sign is produced from applying the multiplication formula: <span class="math inline">\(v_i = -\omega_i \times q_i\)</span>. Here, -<span class="math inline">\(\omega_i\)</span> is (0,-1,0), which will invert the sign of the z axis.</p>
    <p>Alternatively, you could just apply the formula for each vector to determine the linear velocity. Less error prone even though it takes more time.</p>
    </blockquote>
    <p><u>3rd, that’s it!</u></p>
    <p>We now have the elements necessary to calculate the forward kinematic of the robot <span class="math inline">\(T(\theta)\)</span> for any given theta</p>
    <h1 id="chapter-5-velocity-kinematics-and-statics">Chapter 5: Velocity, Kinematics, and Statics</h1>
    <h2 id="terms-2">Terms</h2>
    <p><strong>Jacobian</strong></p>
    <ul>
    <li><p>A determinate which describes the transformation factor of a matrix</p>
    <ul>
    <li>I.e., after the determinate is applied, the area of the original matrix will change by a factor of what?</li>
    </ul></li>
    <li><p>Represented by the time derivative of the matrix</p></li>
    </ul>
    <p><strong>Singularity</strong></p>
    <ul>
    <li>Robot configurations where <span class="math inline">\(J_1(\theta)\)</span> and <span class="math inline">\(J_2(\theta)\)</span> will be co-linear, resulting in a singular matrix for the Jacobian <span class="math inline">\(J(\theta)\)</span></li>
    </ul>
    <p><strong>Space Jacobian</strong></p>
    <ul>
    <li>Jacobian in fixed (space) frame coordinate</li>
    </ul>
    <p><strong>Body Jacobian</strong></p>
    <ul>
    <li>Jacobian in the end-effector (or body) frame coordinates</li>
    </ul>
    <p><strong>End-Effector Velocity</strong></p>
    <ul>
    <li><p>Also referred to as endpoint velocity (<span class="math inline">\(v_{tip}\)</span>)</p></li>
    <li><p>Since the end effector can have any x, y, and theta value depending on its configuration, the time derivative of this vector will yield a Jacobian matrix that can be used to calculate the end-effector’s <span class="math inline">\(v_{tip}\)</span></p></li>
    </ul>
    <hr />
    <h2 id="velocity-kinematics">Velocity Kinematics</h2>
    <ul>
    <li>The Jacobian matrix provides the relation between joint velocities and end-effector velocitities of a robot manipultor.</li>
    <li>Since the joints move with certain velocities, it is useful to know the velocity of the end-effector velocity: <span class="math inline">\(v_{tip}\)</span></li>
    <li>Here, we are calculating the velocity with Twists.</li>
    <li>Since the Jacobian is a matrix, we need to understand what all of the values mean:</li>
    </ul>
    <p><span class="math display">\[
    J(\theta) = 
    \begin{bmatrix}
    \dot{x}_{j1} &amp; \dot{x}_{j2} &amp; ... &amp; \dot{x}_{jn} \\
    \dot{y}_{j1} &amp; \dot{y}_{j2} &amp; ... &amp; \dot{y}_{jn} \\
    \dot{z}_{j1} &amp; \dot{z}_{j2} &amp; ... &amp; \dot{z}_{jn}
    \end{bmatrix}
    \]</span></p>
    <ul>
    <li>Each column represents the <u>effect on <span class="math inline">\(v_{tip}\)</span></u> due to variation in each joint velocity</li>
    </ul>
    <h2 id="manipulability-ellipsoids---joint-velocities">Manipulability Ellipsoids - Joint Velocities</h2>
    <p>The joint velocities are typically graphed in a 2D grid, where the possible joint velocities are represented as a square in the <span class="math inline">\(\dot{\theta_1}-\dot{\theta_2}\)</span> space.</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-26-16-20-21-image.png" /></p>
    <p>This set of values can then be passed to the Jacobian to return the parallelogram of <strong>possible end-effector velocities.</strong> :</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-26-16-20-12-image.png" /></p>
    <p>Note: Typically, the joint velocities are shown as a sphere. When they are, an ellipsoid appears to show the end-effector velocities instead of a parallelogram.</p>
    <ul>
    <li><p>These ellipses are called <strong>Manipulability Ellipsoids</strong></p></li>
    <li><p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-26-16-22-10-image.png" /></p></li>
    </ul>
    <h2 id="force-ellipsoids---joint-torques">Force Ellipsoids - Joint Torques</h2>
    <p>You can also map the joint torques onto a 2D grid. When passed through the Jacobian, this will return the limits of the end-effector forces.</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-26-16-36-10-image.png" /></p>
    <ul>
    <li>The resulting ellipsoid is called the <strong>force ellipsoid.</strong></li>
    </ul>
    <p>Here’s how to find Tau (<span class="math inline">\(\tau\)</span>)</p>
    <ul>
    <li><p>Let <span class="math inline">\(\tau\)</span> = vector of joint torques (forces)</p>
    <p>                                          <span class="math inline">\(power = \dot{\theta}^T\times\tau\)</span> = <span class="math inline">\(v_{tip}^T \times f_{tip}\)</span></p></li>
    </ul>
    <p><span class="math display">\[
    = \dot{\theta} \times \tau = (J(\theta)\dot{\theta})^T \times f_{tip} \newline
    = \dot{\theta} \times \tau = \dot{\theta} \times J^T(\theta) \times f_{tip} \newline
    \tau = J^T(\theta) \times f_{tip}
    \]</span></p>
    <ul>
    <li><p>Tau is useful for <strong>force control:</strong> If we want the robot to generate the force <span class="math inline">\(f_{tip}\)</span> as its end-effector, the motors must generate joint torques and forces equal to <span class="math inline">\(J^T(\theta) \times f_{tip}\)</span></p></li>
    <li><p>If <span class="math inline">\(J^T(\theta)\)</span> is invertible: <span class="math inline">\(J^{-T}(\theta)\tau = f_{tip}\)</span></p>
    <ul>
    <li>This formula is used to produce the force ellipsoids</li>
    </ul></li>
    </ul>
    <h2 id="space-jacobian">Space Jacobian</h2>
    <p>Other than representing the end-effector velocity as <span class="math inline">\(v_{tip}\)</span>, we can represent it by the twist <span class="math inline">\(V_s\)</span></p>
    <p><span class="math display">\[
    V_s = J_s(\theta)\dot{\theta} = [J_{s1}(\theta)J_{s2}(\theta)...J_{sn}(\theta)]\dot{\theta} \newline
    \]</span></p>
    <p>Generalized the <strong>Space Jacobian</strong> is defined as:</p>
    <p><span class="math display">\[
    J_s(\theta)\in\real^{6 \times n}, n = 2
    \]</span></p>
    <p>Since the space jacobian is dependend on joints and angle rotations, we can derive the following example for a RRRP robot:</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-27-16-04-09-image.png" /></p>
    <p>Since the Jacobian is a matrix, we will need to fill in every ith column:</p>
    <ul>
    <li><p>Denote the ith column of <span class="math inline">\(J_S(\theta)\)</span> by <span class="math inline">\(J_{si} = (\omega_{si},v_{si})\)</span></p></li>
    <li><p>Observe that <span class="math inline">\(\omega_{s1}\)</span> is constant and in the <span class="math inline">\(\hat{z}_s\)</span> direction: <span class="math inline">\(\omega_{s1} = (0,0,1)\)</span>. Choosing q1 as the origin, <span class="math inline">\(v_{s1} = (0,0,0)\)</span></p></li>
    <li><p><span class="math inline">\(\omega_{s2}\)</span> is also constant in the <span class="math inline">\(\hat{z}_s\)</span> direction, so <span class="math inline">\(\omega_{s2} = (0,0,1)\)</span>. Choose q2 as the point (<span class="math inline">\(L_1c_1,L_1s_1,0\)</span>), where <span class="math inline">\(c_1 = cos\theta_1, s_1 = sin\theta_1\)</span>. Then <span class="math inline">\(v_{s2} = -\omega_2 \times q_2 = (L_1s_1, -L_1c_1,0).\)</span></p></li>
    <li><p>The direction of <span class="math inline">\(\omega_{s3}\)</span> is always fixed in the <span class="math inline">\(\hat{z}_s\)</span> direction regardless of the values of <span class="math inline">\(\theta_1\)</span> and <span class="math inline">\(\theta_2\)</span>, so <span class="math inline">\(\omega_{s3} = (0,0,1).\)</span> Choosing <span class="math inline">\(q_3 = (L_1c_1 + L_2c_{12},L_1s_1 + L_2s_{12},0),\)</span> where <span class="math inline">\(c_{12} = cos(\theta_1 + \theta_2), s_{12} = sin(\theta_1 + \theta_2)\)</span>, it followsthat <span class="math inline">\(v_{s3} = (L_1s_1 + L_2s_{12}, -L_1c_1 - L_2c_{12}, 0).\)</span></p></li>
    <li><p>Since the finl joint is prismatic, <span class="math inline">\(\omega_{s4} = (0,0,0)\)</span>, and the joint-axis direction is given by <span class="math inline">\(v_{s4} = (0,0,1)\)</span>, the Space Jaobian is therefore:</p></li>
    <li><p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-27-16-27-41-image.png" /></p></li>
    </ul>
    <h2 id="body-jacobian">Body Jacobian</h2>
    <p>The Body Jacobian transforms joint veocities into the body twist:</p>
    <p><img src="/home/ronald/.var/app/com.github.marktext.marktext/config/marktext/images/2020-06-27-17-19-17-image.png" /></p>
    <p>Here is a 5R Robot. The end effector frame is denoted as <span class="math inline">\({b^{\prime\prime}}\)</span> since the frame is shifted twice due to the angle changes from the rotations of joints 4 and 5.</p>
    <p>To find <span class="math inline">\(J_{b3}\)</span>, find <span class="math inline">\(T_{bb^{\prime\prime}}\)</span></p>
    <p><span class="math display">\[
    J_{b3} = [Ad_{T_{b^{\prime\prime}b}}]\beta_3 \newline
      = [Ad_{T_{bb^{\prime\prime}}^{-1}}]\beta_3 \newline
    = [Ad_{e^{-[\beta_5]\theta_5}e^{-[\beta_4]\theta_4}}]\beta_3
    \]</span></p>
    <p><strong>Generalized:</strong> the Body Jacobian <span class="math inline">\(J_b(\theta)\)</span> is defined by</p>
    <p><span class="math inline">\(V_b = J_b(\theta)\dot{\theta}\)</span></p>
    <p><strong>where</strong> <span class="math inline">\(J_b(\theta) = [J_{b1}(\theta)...J_{b(n-1)}(\theta)J_{bn}] \in \real^{6 \times n}\)</span></p>
    <p><strong>with</strong> <span class="math inline">\(J_{bn} = B_n\)</span></p>
    <p><strong>and</strong> <span class="math inline">\(J_{bi}(\theta) = [Ad_{e^{-[B_n]\theta_n}...e^{-[B_{i+1}]\theta_{i+1}}}]\)</span></p>
    <h3 id="relationship-between-space-jacobian-and-body-jacobian">Relationship between Space Jacobian and Body Jacobian</h3>
    <p><span class="math inline">\(J_b(\theta) = [Ad_{T_{bs}}]J_s(\theta)\)</span></p>
    <p><span class="math inline">\(J_s(\theta) = [Ad_{T_{sb}}]J_b(\theta)\)</span></p>
    <h2 id="statics-of-open-chains">Statics of Open Chains</h2>
    <p><span class="math inline">\(\tau_{motion}(t): Inverse\ Dynamics\)</span></p>
    <p>To resist a wrench <span class="math inline">\(-F_*\)</span> applied tothe end-effector at configuration <span class="math inline">\(\theta\)</span>, the joint torques/forces must be at:</p>
    <p><span class="math inline">\(\tau = J_*^T(\theta)F_*\)</span></p>
    <p>where * = b indicates th Jacobian and the wrench represented in {b} and * = s indicates the Jacobian and wrench represented in {s}. This can be used in force control of the robot.</p>
    <p><u>Remember, the Jacbian shows the relationships for te end-effector velocities. These relationships can be used to determine the <strong>corrective force</strong> needed to maintain stability when an opposing force is applied. </u></p>
    <h2 id="kinematic-singularities">Kinematic Singularities</h2>
    <p>Since the Jacobian is a matrix, we can determine its rank:</p>
    <h3 id="ranking-jacobians">Ranking Jacobians</h3>
    <p>The rank of a matrix is the number of independent rows contained in the matrix. A row is independent if it matches all of the following criteria:</p>
    <ul>
    <li><p>The row must contain at least one non-zero value</p></li>
    <li><p>The row must be unique</p></li>
    <li><p>The row must not be a multiple of another</p></li>
    <li><p>The row must not be a linear combination of another row</p></li>
    </ul>
    <p>Remember that:</p>
    <ul>
    <li><span class="math inline">\(J(\theta) \in \real^{6 \times n}\)</span></li>
    </ul>
    <p>Therefore:</p>
    <ul>
    <li><span class="math inline">\(rank\ J(\theta) &lt;= min(6,n)\)</span></li>
    </ul>
    <p>if <span class="math inline">\(J(\theta) = min(6,n)\)</span>, then the Jacobian is at <strong>full rank</strong>.</p>
    <p>If <span class="math inline">\(J(\theta) &lt; max\ rank\ J(\theta)\)</span>, then the Jacobian is in <strong>singularity at</strong> <span class="math inline">\(\theta\)</span></p>
    <h3 id="classifing-jacobians">Classifing Jacobians</h3>
    <p>For <span class="math inline">\(J(\theta) \in \real^{6 \times n}\)</span>:</p>
    <ul>
    <li><p>When n &lt; 6: The Jacobian is <strong>tall</strong> and <strong>kinematically deficient</strong>.</p></li>
    <li><p>When n = 6: The Jacobian is <strong>square</strong> (capable of general 6-dimenional body motions)</p></li>
    <li><p>When n &gt; 6: The Jacobian is <strong>fat</strong> (it has more columns than rows like a 7R robot) and is considered <strong>redundant</strong>.</p></li>
    </ul>
    <h2 id="manipulability">Manipulability</h2>
    <p>A robot configuration is either singular, or it is not. However, it is useful to describe “how close” the robot is to being singular.</p>
    <p>We can assign a measure ofjust how close the robot is to being singular according to how close the ellipsoid is to collapsing.</p>
    <p><strong>Eigenvector:</strong></p>
    <ul>
    <li>A vector when after a transformation is applied to it only scaled instead of rotating</li>
    </ul>
    <p><strong>Eigenvalue:</strong></p>
    <ul>
    <li>The amount that the vector scaled</li>
    </ul>
    <p><img src="/home/ronald/Downloads/IMG_20200627_202620.jpg" /></p>
    <p>We can then use a single number to represent how close the ellipsoid is to singularity: <strong>This is called Manipulabiliy</strong></p>
    <p><img src="/home/ronald/Pictures/IMG_20200627_203419.jpg" /></p>
    <p>It’s more useful to visualize the manipulability ellipsoid using the body Jacobian than the space Jacobian, since the body Jacobian measures linear velocities at the origin of the end-effector frame, which has a more intuitive meaning than the linear velocity at the origin of the space frame. If the robot has nnn joints, then the body Jacobian <span class="math inline">\(J_b\)</span> is 6 x n. We can break <span class="math inline">\(J_b\)</span> into two sub-Jacobians, the angular and linear Jacobians:</p>
    <p><span class="math display">\[
    J_b = 
    \begin{bmatrix}
    J_{bw} \\
    J_{bv} 
    \end{bmatrix}
    \]</span></p>
    <p>The dimension of <span class="math inline">\(J_{bv}J_{bv\prime}^T\)</span>, which is used to generate the linear component of the manipulability ellipsoid is:</p>
    <ul>
    <li>3x3</li>
    </ul>
    <p>As a Full Rank Jacobian approaches singular configuration, the following occurs to the <strong>manipulability ellipsoid</strong>:</p>
    <ul>
    <li><p>The length of one principal axis approaches zero</p></li>
    <li><p>The interior volume of the ellipsoid approaches zero</p></li>
    </ul>
    <p>As a Full Rank Jacobian approaches singular configuration, the following occurs to the <strong>force ellipsoid</strong></p>
    <ul>
    <li><p>The length of one principal axis approaches infinity.</p></li>
    <li><p>The interior volume of the ellipsoid approaches infinity.</p></li>
    </ul>
  </article>
</body>
</html>
